# 虚拟节点和生命周期



### 一 虚拟节点



#### 1.1 虚拟节点是什么

Vue框架的性能比jQ好，体现在哪里？

jq 为了写法上的方便，无节制的使用DOM操作，而Vue框架会使用开销尽量小的方式来进行DOM操作。

Vue框架使用 **虚拟节点技术** 来实现尽可能小代价的进行DOM操作的效果。

什么是虚拟节点? 虚拟节点本质上是一个js对象，用于描述DOM节点的结构。

```javascript
// 真实DOM视图
<div id='app'>
	<p>1111</p>
</div>
// 把以上DOM视图用虚拟节点描述如下
// attrs表示属性节点列表
// children标准字节点列表
// tag表示当前的标签类型。
// 如果字节点又是标签，则嵌套虚拟节点描述。
const vNode = {
	tag:'div',
	attrs:[
		{id:'app'}
	],
	children:[
		{
			tag:'p',
			attrs:[],
			children:['1111']
		}
	]
}
```

虚拟节点是如何获得的？

我们会把组件的template写成一个字符串模板，组件的创建过程中，Vue会把template模板编译成虚拟节点。

最开始是把template编译成AST语法（抽象语法树），AST就类似于嵌套的JSON结构。最后在生成虚拟节点。

生成了虚拟节点后，Vue又会根据虚拟节点生成一个真实的DOM节点挂载到页面上，这样的视图才是响应式的。



有了虚拟节点如何进行视图更新？

**首先，Vue数据会绑定到虚拟节点中，当Vue数据更新时，会通知对应的虚拟节点更新。**

**虚拟节点更新后，比较更新前的虚拟节点和更新后的虚拟节点之间的差别，利用diff算法得出最终以何种DOM操作方式更新视图。**

每次数据变化，都会经历以上的过程。最后一步采用DOM操作更新视图。



添加渲染 v-if 如果是false，则不会把v-if 所在的DOM阶段编译到虚拟节点中，因此不会出现再最终的视图中。

v-if 可以控制是否把DOM节点编译成虚拟节点。

v-show会默认把DOM节点编译成虚拟节点，只不过最后会按照条件通过样式决定是否显示。



**总结：**

**挂载视图的过程：**

**1：Vue把template生成编译成虚拟节点。**

**2：Vue根据虚拟节点生成响应式的真实DOM节点并挂载到页面上。**

**视图更新过程：**

**1：Vue数据变化导致虚拟节点更新。**

**2：比较更新前后更新后的虚拟节点。**(diff算法)

**3：采用开销最小的方式进行DOM操作更新真实的视图。**



#### 1.2 render函数

我们写组件的template模板是字符串的写法，这样写很直观，利于我们写布局。

但是字符串template性能不好，因为Vue需要把字符串编译成虚拟节点。

其实我们可以通过render函数直接生成虚拟节点，这样性能好，但是不利于写布局。

```javascript
//假设这是组件的template模板
<div id='app'>
	<p>1111</p>
</div>
// 利用render函数之间生成虚拟节点.其中h是Vue源码中的createElement函数,专门用于生成虚拟节点
// h 函数的三个参数,分别是虚拟节点描述中的3个属性,tag,attrs,children
const myComponent = {
	render(h){
		return h('div',{attrs:{id:'app'},[
			h('p',null,['1111'])
		]})
	}
}
```



#### 1.3 视图更新时的key

虚拟节点更新后，需要比较更新前和更新后的虚拟节点，最后通过diff算法得出最终以何种方式更新视图。

Vue默认会用开销最小的方式更新视图。这里涉及到两个最基础的更新视图方式：

1：就地更新。

2：替换更新。

就地更新的意思是，不删除和移动原DOM节点，直接修改当前DOM节点。更新前更新后的节点是同一个节点。

替换更新的意思是，可能会删除和移动原DOM节点，如果要删除原节点，会生成一个新的节点。

Vue在如果可以的情况下，尽可能的使用就地更新策略。因为这样开销最小。

但是有些时候就地跟新策略不是我们需要的效果，例如列表渲染的过程中，就地更新经常会给我们带来困难。

如果不希望视图更新时Vue采用就地更新策略，只需要：

**更新前后虚拟节点的key不一样！**



以就地跟新还是替换更新视图，是diff算法中的一个部分。

这部分的大概逻辑是这样：

1：diff算法采用同级比较策略。

2：同级比较该虚拟节点的tag和key在更新前后是否一致。

3：如果 tag 和 key 更新前后的值是一样的，证明更新前后的节点是同一个节点，采用就地跟新。

4：如果tag 和 key 有一个不一样，证明更新前后的节点不是同一个节点，采用替换更新。

至于Vue是如何做替换更新的，这是diff算法最难的部分，这里不再赘述，感兴趣同学，可自信百度看资料。



这时候，试想一下，为什么列表渲染中，应该设置key为各不相同的值，而不能用循环的下标。



### 二 生命周期

什么是生命周期，生命周期其实都是函数，也叫生命周期钩子函数。它们在Vue创建和运行的特定阶段触发。

生命周期钩子函数有8个。动态组件有2个。



#### 2.1 创建阶段生命周期

在Vue实例的创建过程中，会触发4个钩子函数，这些钩子函数只会触发一次。

创建阶段大概又分为两个小阶段。



**1：数据设置监听阶段**，此阶段专门用于给Vue数据设置数据监听。这个阶段触发两个钩子函数。

**beforeCreate** 创建前。这个钩子函数没什么用。

这个时候Vue数据并没有变成Vue实例属性，也没有通过Object.defineProperty设置数据监听。

**created** 创建后。这个钩子函数用于Vue数据的初始化。

此时数据已经变成了Vue的属性。并且设置了数据监听。



**2：视图挂载阶段**，此阶段用于生成虚拟节点，并且挂载视图。这个阶段触发两个钩子函数。

**挂载阶段会把template模板编译成虚拟节点，最终根据虚拟节点生成真实的DOM节点，并且替换el所在挂载点。**

**beforeMount** 挂载前。这个钩子函数没有什么用。

这个时候虚拟节点都还没有生成。

**mounted** 挂载后。这个钩子函数用于操作Vue视图。

这个时候虚拟节点已经生成，并且根据虚拟节点生成了最终的Vue视图。**这时的视图才是响应式的。**



注意：

template模板是在挂载阶段编译的，

**因此，template上面的插值表达式和指令以及计算属性都是在这个阶段执行的！**



#### 2.2 运行阶段生命周期

Vue实例创建成功后，数据有了监听，并且视图已经变成了响应式。

后续如果视图更新或者组件被销毁，会触发4个钩子函数。



**1：视图更新**。如果数据变化导致了视图更新，这里会触发两个钩子函数，这两个钩子函数有可能触发多次。

**beforeUpdate** ，更新前，这个钩子函数没什么用。

**updated**，更新后，视图更新后触发，可以操作更新后的视图。



**2：组件销毁。**组件有时候会被自动销毁，例如组件所在节点被删除。这里会触发两个钩子函数。

**beforeDestroy**，销毁前。这个钩子函数没有什么用。

**destroyed**，销毁后。这个钩子函数用于删除定时器和解绑Vue实例绑定的自定义事件等。



#### 2.3 父子组件和兄弟组件的生命周期钩子顺序

如果在解析父组件的template过程中遇到了子组件的挂载，

**会暂时停止父组件的模板编译，转而进入子组件的创建过程。**因此父子组件的生命周期钩子函数顺序应该是：

父beforeCreate

父created

父beforeMount

​	子beforeCreate

​	子created

​	子beforeMount

​	子mounted

父mounted

如果父组件template中有两个兄弟组件，则兄弟组件必须在都创建完成后才挂载。因此顺序是：

父beforeCreate

父created

父beforeMount

​	子1beforeCreate

​	子1created

​	子1beforeMount

​	子2beforeCreate

​	子2created

​	子2beforeMount

​	子1mounted

​	子2mounted

父mounted



如何让父组件挂载完成之后再挂载子组件？

可以通过条件渲染 v-if 控制字组件一开始不创建，父组件挂载完成之后再把条件渲染条件换成true。



