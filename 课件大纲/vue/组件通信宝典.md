# 组件通信宝典



### 一 父传子

父组件在子组件挂载的自定义标签上给子组件的对应数据赋值。(前子后父)

子组件接收父组件的数据，需要通过props进行声明。简写是写成数组的形式。

父组件可以传递多种数据类型给子组件，例如：Number，String，Array，Function，Object，Boolean。

```JavaScript
// 子组件
{
	props:['msg']
}
// 父组件
{
	template:`
		<div>
			<box :msg='msg' />
		</div>
	`,
	data(){
		return {
			msg:'父组件数据'
		}
	}
}
```

props的验证写法：

```javascript
// 子组件的props还可以写成对象。
// default表示如果没有得到父组件传值时使用的默认值。
// type表示父组件必须传递什么样的数据类型.
// require表示这个数据必须接受父组件的值.
// validator用于封装自定义验证逻辑,return验证成功与否的条件.参数value是父组件传递的值.
{
	props:{
       msg:{
            default:'默认值',
        	type:Number,
            require:true,
            validator(value){
                return value<10
            }
       }
    }
}
```



### 二 子传父

子传父的逻辑较复杂，非常类似两个函数间传递局部变量的逻辑。

实现方法类似反向数据流的方法。

普遍逻辑：

**1：父组件声明一个方法接收子组件数据。**

**2：子组件想办法调用这个方法并传入子组件数据。**

子组件如果调用父组件方法？

1：父组件把方法主动传递给子组件。

2：给子组件添加一个自定义事件，子组件触发这个自定义事件时调用父组件的方法。

```javascript
// 子组件
const myComponent = {
    template:`
        <div>
            <h3>子组件</h3>
            <input type='text' v-model='msg' />
            <button @click='fn'>按钮</button>
        </div>
    `,
    data(){
    	return {msg:''}
    },
    methods:{
        fn(){
            // 点击按钮触发myevent事件,并且传递子组件数据.
            this.$emit("myevent",this.msg)
        }
    }
}
// 父组件,在子组件挂载处通过 @myevent='fn' 给子组件添加自定义事件myevent
 const App = {
     template:`
        <div id='app'>
            <h3>来自子组件的msg:{{str}}</h3>
            <hr />                
            <div is='myComponent' @myevent='fn'></div>
        </div>
	 `,
     data(){ return { str:'' } },
     components:{myComponent},
     methods:{
         fn(msg){
             this.str = msg;
         }
     }
 }
```



### 三 反向数据流做组件通信 （本质上还是父传子）

除了父传子，子传父，还会有更复杂的组件通信使用场景。例如：兄弟传兄弟。

兄弟传兄弟可以使用最特憨憨的做法来实现，可以先做一个次子传父，再做一次父传子。

这种做法在更复杂的情况下会变得极度麻烦。

甚至有些时候，你需要关系很远的N个组件同时共享一个数据。



这个时候，可以通过反向数据流间接共享这个数据：

**1：把需要共享的数据提到这些组件的共同祖先元素上。**

**2：把修改共享数据的逻辑方法也写到这些组件共同的祖先元素上。**

**3：把数据通过props传递给这些组件。**



### 四 bus万能共享

反向数据流实际上更像是一种 “状态管理” 的操作。它实际上可以让N个组件共享一个数据。

如果单纯只是两个关系很远的组件需要共享数据，还可以使用bus共享。



把子传父的实现逻辑稍做修改，就可以得出bus共享的核心思路。

如果要实现A组件传递数据给B组件：

**1：B组件声明一个方法接收A组件数据。**

**2：A组件想办法调用这个方法并传入A组件数据。**



在子传父的数据共享例子中，我们是给子组件添加了一个自定义事件，其实给父组件添加自定义事件也可以实现。

实际上，只要方便获取组件，给哪个组件实例添加自定义事件都是可以的。

为什么子传父时需要给子组件添加自定义事件，只是因为在子组件中可以方便的通过this获取子组件而已。

如果给父组件绑定自定义事件，需要在子组件中获取父组件中，会比较麻烦。



如果是兄弟传兄弟，不管给哪个兄弟组件添加自定义事件，另一个组件都很难获取到绑定了自定义事件的组件。

因此，我们需要一个中间Vue实例来添加自定义事件，这个Vue实例可以作为全局变量，方便两个兄弟组件获取。

这个中间Vue实例就作为输送共享数据的"bus"，把数据从A组件运送到B组件。



以上的A组件传递数据给B组件逻辑可以完整表示为：

**1：B组件声明一个方法接收A组件数据。**

**2：给bus实例通过 $on 添加一个自定义事件，这个自定义事件触发时，调用这个B组件的方法。**

**3：A组件通过 $emit 触发 bus 实例的这个自定义事件，并传入A组件数据。**



```JavaScript
// 把组件A的msg传递给B组件.B组件用str接收.

// 第三方的Vue实例,用于添加自定义事件.它是全局变量,方便两个变量获取.
const bus = new Vue();

//组件A
const A = {
	template:`<div> <button>按钮</button> </div>`,
	data:{msg:"AAA"},
    methods:{
        sendMsg(){
            // 触发bus绑定的myevent事件,并传入A组件的msg数据
            bus.$emit('myevent',this.msg);
        }
    }
}
// 组件B
const B = {
	template:`<div>{{str}}</div>`,
	data:{str:""},
    methods:{
        fn(val){this.str = val}
    },
    mounted(){
        // 给bus添加一个自定义事件myevent,事件触发时,调用B组件的方法fn
        bus.$on('myevent',this.fn)
    }
}
```



### 五：其他的组件通信方式。

常见的组件通信方式：父传子，子传父，bus。

如果只是需要在两个组件间共享数据，还有一些不推荐的做法。



5.1 通过 $parent 和 $children 获取父组件和子组件，再获取其中的数据。

5.2 通过 $refs 属性获取对应组件，再获取其中数据。

5.3 通过$attrs 和 $listeners 共享

5.4 通过inject和provide共享。（项目中是不用的，只在封装插件时用）



这些方法之所以不推荐，都是因为他们类似硬编码，让组件难以复用。 



### 六：多组件共享一个数据

如果是多组件共享一个数据，并且在这个数据变化时需要多组件同时更新视图。

这种需求叫：状态管理。

状态管理有两种做法：

1：反向数据流。

2：使用Vue的一个插件Vuex。（后面学）







