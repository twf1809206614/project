# 作用域和作用域链



### 一 作用域

**什么是作用域？**

作用域就是声明变量的'地点'。程序执行过程中，遇到函数调用，程序会被推入函数作用域中。

**作用域的作用？**

区分不同的变量，对数据进行保护。对变量具有存储和保护的作用。



#### **1.1 作用域分类：**

1：全局作用域 （大括号外面的区域）

2：局部作用域（大括号内部的区域）

其中，局部作用域又分为：

1：函数作用域 （函数{}内部的区域）

2：块级作用域 （非函数{}的其他{}的内部区域）



#### **1.2 不同作用域内的变量：**

全局变量：声明在全局作用域中的变量叫全局变量。

局部变量：声明在局部作用域中的变量叫局部变量。

**其中：函数的形参属于局部变量**



#### 1.3 全局变量和局部变量的可见性：

1：全局变量在程序的任何地方都可以访问。

2：局部变量只能在局部作用域中可以访问。

扩展：

**任何函数内都可以访问全局变量，全局作用域不能访问局部变量，局部作用域A不能访问局部作用域B中的变量**



#### 1.4 作用域的生命周期

1：全局作用域在程序关闭前一直存在，全局变量在程序关闭前一直都可以访问

2：局部作用域在程序退出局部作用域时，局部作用域会被销毁，局部变量会随着局部作用域的销毁而销毁。

函数内的局部变量，会在函数结束调用之后被销毁。（被销毁后就无法访问了）



#### 1.5：块级作用域

ES6新增的概念。

除了函数大括号之外的其他大括号内的区域就是块级作用域。

**块级作用域内只有通过let和const声明的变量才会变成局部变量。**

var 声明的变量不会变成块级作用域内的局部变量。（变量提升）



### 二 作用域链

若程序中出现多个同名变量，如何区分他们呢？使用作用域链机制进行变量查找可以区分。

如果局部作用域内又存在其他作用域，则这些作用域构成了一个 '作用域链'。

```JavaScript
// 以下程序出现的作用域链是：add => fn => 块级作用域 => 全局作用域
{
	function fn(){
		function add(){
			consle.log(x)
		}
	}
}
```

如果作用域链内出现了多个同名变量，则需要进行变量查找来区分他们。

```javascript
// 以下程序出现的作用域链是：add => fn => 块级作用域 => 全局作用域
// 以下程序如果调用add打印x，打印的是10.不会打印20
{
    let x = 20;
	function fn(){
        var x = 10;
		function add(){
			consle.log(x)
		}
	}
}
```

**变量查找步骤：**

**1：写出访问变量代码所在的作用域链**

**2：沿着这个作用域链从里到外逐层查找变量声明，如果查找到，就停止查找（就近原则）**



### 三 变量提示 （预解析）

var 声明的变量和函数声明在程序的解析阶段会被提升到本作用域的顶端

**只提升声明部分！不提升赋值部分！**

预解析完成之后，程序按照解析之后的js进行运行。

```javascript
console.log(x);
var x = 10;
show();
function show(){
	console.log(100)
}

// 以上代码预解析之后变成下面的的顺序,最后执行的是下面的代码顺序。
var x;
function show(){
	console.log(100)
}
console.log(x);
x = 10;
show();

```

**let 和 const 声明的变量不会有提升现象！**

**函数表达式只有声明的变量提升了！**

**var 在块级作用域中声明变量会提升到全局作用域中成为全局变量！**

**如果变量提升和函数提升冲突了，（标识符一致），以函数声明为准！**

