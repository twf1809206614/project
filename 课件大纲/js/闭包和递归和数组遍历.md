# 闭包和递归和数组遍历

### 一 闭包

#### 1.1 什么是闭包？

闭包有很多不同的描述。

1：闭包可以在函数外面访问闭包内部的变量。

2：闭包创建一个私有的不会被销毁的作用域，用于存储局部变量。

3：闭包就是函数套函数（最白痴的说法）

闭包表现形式：

```javascript
// 这里的add作用域构成了一个闭包.
function add(){
    let x = 10;
    return function(){
        console.log(x)
    }
}
// 闭包返回子函数
let fn = add();

// 通过调用子函数来访问局部变量x
fn();
// ------------------------------------------------------------------------------

// 这里的add作用域构成了一个闭包。
function add(){
    let x = 10;
    oBtn.onclick = function(){
        console.log(x)
    }
}
// 通过点击oBtn来触发子函数，以此来访问局部变量x。
add();
oBtn.click()

```



#### 1.2 闭包的作用

闭包有两个主要作用：1：存储。2：保护

闭包可以把数据存储到局部作用域中，在函数调用结束后局部变量也不会被销毁，可以一直访问。

闭包存储的变量本质上还是局部变量，在函数外部无法直接访问，但是可以通过闭包的子函数访问。

总结：闭包可以让变量同时具有全局变量任何时间都可以访问的特性，又具有局部变量不能在外部直接访问的特性



#### 1.3 闭包的原理

闭包是如何让局部作用域在函数调用结束之后不会被销毁的？

这里需要先了解 js 的垃圾回收机制。

js 垃圾回收机制：如果一个变量无法再访问，则 js 会自动将其回收（销毁），以释放内存。

例如，函数调用结束，函数作用域被销毁，没有了函数作用域，则无法访问该作用域中的变量，

因此 js 垃圾回收机制会自动销毁局部变量。

只要让 js 认为局部变量还有可能继续得到访问，则 js 垃圾回收机制就不会销毁局部变量。

闭包通过调用子函数来访问局部变量，如果子函数可以任意时间调用，则子函数引用的局部变量就是可以在任何时间得到访问的，因此 js 垃圾回收机制就不会销毁局部变量。

**只要闭包内的子函数可以在任意时间调用,则子函数内引入的变量就不会被 js 垃圾回收机制销毁**.



#### 1.4 闭包构成条件

1：父作用域套子函数作用域。

2：子函数引用父作用域内声明的局部变量。

3：子函数还可以在任意时间调用。

### 二 递归

#### 1.1 什么是递归？

简单理解：函数自己触发自己。

#### 1.2 递归的作用

递归的作用类似于循环，所有的循环都可以通过递归来改写，但是不是所有的递归都可以通过循环来代替。

#### 1.3 使用场景

何时用循环，何时用递归？

明确知道重复次数的，用循环，不知道重复次数的，用递归。

两个生活场景：

1：给你一摞扑克牌，让你数有多少张，这里应该是循环的逻辑。因为不管数多少遍，次数是固定的。

2：给你一个骰子，让你扔出6，扔不出继续扔，这里应该是递归的逻辑，因为扔几次出6，是不固定的。

递归用于封装函数上，有些时候我们并不知道需要函数执行多少次才可以得到结果，这种情况都可以使用递归。

```JavaScript
// getNum 是一个求阶乘的函数。参数6意即求1-6的阶乘。
// 因为实参的数字是不确定的，我们不知道需要函数执行多少次才可以得到最终的结果，因此可以使用递归
let num = getNum(6);

function getNum(n){
    return n==1 ? 1 : getNum(n-1)
}

```

#### 1.4 递归注意事项

循环需要判断条件以结束循环，递归也需要条件终止循环。

死循环不会报错，但是死递归会报错。

```javascript
getNum();

// 这就是一个死递归
function getNum(){
	getNum();
}

```

常规递归的性能特别差，因此能不用递归就尽量不用递归。有些公司的规范中明确要求不能使用递归。

为何递归的性能特别差？

因为递归的作用域是嵌套的，递归10次的作用域就嵌套10次，只有最后一次递归结束释放作用域后，才逐层往外释放父级作用域。第一次调用的作用域在最后才能被释放。

ES6提供了尾递归优化，递归不再有性能问题，但是写法变得更不直观。感兴趣有能力的同学可以研究一二。



### 三 数组的遍历方法

常用数组遍历方法：

1：arr.forEach()；(常规遍历，没有返回值)

2：arr.map()；(遍历某个数组，返回新数组)

3：arr.filter()；(遍历某个数组，按条件过滤出新数组) 

4：arr.every()； (遍历数组，返回布尔值，用于判断)

5：arr.some()；(遍历数组，返回布尔值，用于判断)

6：arr.reduce；(遍历数组，返回各项的计算值)

7：arr.find() ;  (遍历数组，返回指定的元素)

8：arr.find() ;  (遍历数组，返回指定的元素的下标)





